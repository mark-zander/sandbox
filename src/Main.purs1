module Main where

import Data.Array
import Data.Either
import Data.Maybe
import Data.Tuple
import Prelude

import Data.ArrayView as Aview
import Data.String as S
import Effect (Effect)
import Effect.Console (log)

basis :: Array String
basis = ["e", "e1", "e2", "e3", "e4", "e23", "e31", "e12", "e43", "e42", "e41", "e321", "e124", "e314", "e234", "e1234"]

emptyAS :: Array String
emptyAS = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""]

type BasisTable = Array (Array String)

-- Geometric product basis table
gpTable :: Array (Array String)
gpTable =
  [ ["1",  "e1", "e2", "e3", "e4",              "e23", "e31", "e12", "e43", "e42", "e41",      "e321", "e124", "e314", "e234", "e1234"]

  , ["e1",  "1", "e12", "-e31", "-e41",         "-e321", "-e3", "e2", "e314", "-e124", "-e4",  "-e23", "-e42", "e43", "e1234", "e234"]
  , ["e2",  "-e12", "1", "e23", "-e42",         "e3", "-e321", "-e1", "-e234", "-e4", "e124",  "-e31", "e41", "e1234", "-e43", "e314"]
  , ["e3",  "e31", "-e23", "1", "-e43",         "-e2", "e1", "-e321", "-e4", "e234", "-e314",  "-e12", "e1234", "-e41", "e42", "e124"]
  , ["e4",  "e41", "e42", "e43", "0",           "e234", "e314", "e124", "0", "0", "0",         "e1234", "0", "0", "0",         "0"]

  , ["e23",  "-e321", "-e3", "e2", "e234",      "-1", "-e12", "e31", "e42", "-e43", "-e1234",  "e1", "e314", "-e124", "-e4",   "e41"]
  , ["e31",  "e3", "-e321", "-e1", "e314",      "e12", "-1", "-e23", "-e41", "-e1234", "e43",  "e2", "-e234", "-e4", "e124",   "e42"]
  , ["e12",  "-e2", "e1", "-e321", "e124",      "-e31", "e23", "-1", "-e1234", "e41", "-e42",  "e3", "-e4", "e234", "-e314",   "e43"]
  , ["e43",  "e314", "-e234", "e4", "0",        "-e42", "e41", "-e1234", "0", "0", "0",        "-e124", "0", "0", "0",         "0"]
  , ["e42",  "-e124", "e4", "e234", "0",        "e43", "-e1234", "-e41", "0", "0", "0",        "-e314", "0", "0", "0",         "0"]
  , ["e41",  "e4", "e124", "-e314", "0",        "-e1234", "-e43", "e42", "0", "0", "0",        "-e234", "0", "0", "0",         "0"]

  , ["e321",  "-e23", "-e31", "-e12", "-e1234", "e1", "e2", "e3", "e124", "e314", "e234",      "-1", "-e43", "-e42", "-e41",   "e4"]
  , ["e124",  "-e42", "e41", "-e1234", "0",     "-e314", "e234", "-e4", "0", "0", "0",         "e43", "0", "0", "0",           "0"]
  , ["e314",  "e43", "-e1234", "-e41", "0",     "e124", "-e4", "-e234", "0", "0", "0",         "e42", "0", "0", "0",           "0"]
  , ["e234",  "-e1234", "-e43", "e42", "0",     "-e4", "-e124", "e314", "0", "0", "0",         "e41", "0", "0", "0",           "0"]

  , ["e1234", "-e234", "-e314", "-e124", "0",   "e41", "e42", "e43", "0", "0", "0",            "-e4", "0", "0", "0",           "0"]
  ]

-- Exterior product basis table, a copy of above with many values zeroed out.
expTable :: Array (Array String)
expTable =
  [ ["0",  "e1", "e2", "e3", "e4",              "e23", "e31", "e12", "e43", "e42", "e41",      "e321", "e124", "e314", "e234", "e1234"]

  , ["e1",  "0", "e12", "-e31", "-e41",         "-e321", "0", "0", "e314", "-e124", "0",       "0", "0", "0", "e1234",         "0"]
  , ["e2",  "-e12", "0", "e23", "-e42",         "0", "-e321", "0", "-e234", "0", "e124",       "0", "0", "e1234", "0",         "0"]
  , ["e3",  "e31", "-e23", "0", "-e43",         "0", "0", "-e321", "0", "e234", "-e314",       "0", "e1234", "0", "0",         "0"]
  , ["e4",  "e41", "e42", "e43", "0",           "e234", "e314", "e124", "0", "0", "0",         "e1234", "0", "0", "0",         "0"]

  , ["e23",  "-e321", "0", "0", "e234",         "0", "0", "0", "0", "0", "-e1234",             "0", "0", "0", "0",             "0"]
  , ["e31",  "0", "-e321", "0", "e314",         "0", "0", "0", "0", "-e1234", "0",             "0", "0", "0", "0",             "0"]
  , ["e12",  "0", "0", "-e321", "e124",         "0", "0", "0", "-e1234", "0", "0",             "0", "0", "0", "0",             "0"]
  , ["e43",  "e314", "-e234", "0", "0",         "0", "0", "-e1234", "0", "0", "0",             "0", "0", "0", "0",             "0"]
  , ["e42",  "-e124", "0", "e234", "0",         "0", "-e1234", "0", "0", "0", "0",             "0", "0", "0", "0",             "0"]
  , ["e41",  "0", "e124", "-e314", "0",         "-e1234", "0", "0", "0", "0", "0",             "0", "0", "0", "0",             "0"]

  , ["e321",  "0", "0", "0", "-e1234",          "0", "0", "0", "0", "0", "0",                  "0", "0", "0", "0",             "0"]
  , ["e124",  "0", "0", "-e1234", "0",          "0", "0", "0", "0", "0", "0",                  "0", "0", "0", "0",             "0"]
  , ["e314",  "0", "-e1234", "0", "0",          "0", "0", "0", "0", "0", "0",                  "0", "0", "0", "0",             "0"]
  , ["e234",  "-e1234", "0", "0", "0",          "0", "0", "0", "0", "0", "0",                  "0", "0", "0", "0",             "0"]

  , ["e1234", "0", "0", "0", "0",               "0", "0", "0", "0", "0", "0",                  "0", "0", "0", "0",             "0"]
  ]


createTerm :: Int -> Int -> Either String String
createTerm a b = err a b $ pure "a." <> basis !! a <> pure " * b." <> basis !! b

err :: forall a. Int -> Int -> Maybe a -> Either String a
err a b (Just x) = Right x
err a b Nothing = Left $ show a <> " " <> show b

ix2 :: forall x. Array (Array x) -> Int -> Int -> Either String x
ix2 tbl a b = err a b $ (tbl !! a) >>= (_ !! b)

data Value = E Int | None

instance showValue :: Show Value where
  show None = "None"
  show (E x) = "(E " <> show x <> ")"

maybeEither :: forall a b. a -> Maybe b -> Either a b
maybeEither a (Just b) = Right b
maybeEither a Nothing = Left a

mkTuple :: String -> Either String Int -> Either String (Tuple String Value)
mkTuple sign (Left l) = Left l
mkTuple sign (Right x) = Right (Tuple sign (E x))

interpEntry :: Either String String -> Either String (Tuple String Value)
interpEntry (Right x)
  | x          ==  "0" = Right $ Tuple "" None
  | x          ==  "1" = mkTuple " + "  $ Right 0
  | x          == "-1" = mkTuple " - " $ Right 0
  | S.take 1 x ==  "e" = mkTuple " + "  $ maybeEither ("interp e = " <> x) $ elemIndex x basis
  | S.take 2 x == "-e" = mkTuple " - " $ maybeEither ("interp -e = " <> x) $ elemIndex (S.drop 1 x) basis
  | otherwise          = Left $ "interp other = " <> x
interpEntry (Left l) = Left $ "interp bad arg = " <> l

modifier :: Either String String -> Either String (Tuple String Value) -> Either String (Array String) -> Either String (Array String)
modifier (Right term) (Right (Tuple sign (E ix))) (Right r) = maybeEither ("modify " <> show ix) (modifyAt ix (_ <> (sign <> term)) r)
modifier _ (Right (Tuple _ None)) r = r
modifier a b c = Left $ show a <> " <> " <> show b <> " <> " <> show c

genRow :: Array (Array String) -> Int -> Int -> Either String (Array String) -> Either String (Array String)
genRow _ _ _ (Left r) = Left r
genRow tbl a b res =
  if b > 15 then res
  else genRow tbl a (b + 1) $ modifier (createTerm a b) (interpEntry $ ix2 tbl a b) res

genMult :: Array (Array String) -> Int -> Either String (Array String) -> Either String (Array String)
genMult _ _ (Left r) = Left r
genMult tbl a res =
  if a > 15 then res
  else genMult tbl (a + 1) $ genRow tbl a 0 res

-- mapmap :: Either String (Array String)
--mapmap tbl = (foldr append <<< zipWith append basis <<< map (\x -> ": 0" <> x <> "\n")) <$> genMult tbl 0 (Right emptyAS)
combine :: Array String -> String
combine = fold <<< zipWith append basis <<< map (\x -> ": 0" <> x <> ",\n")

xxx :: Array (Array String) -> Either String String
xxx tbl = combine <$> genMult tbl 0 (Right emptyAS)

main :: Effect Unit
main = do
  case xxx gpTable of
    Left l -> log l
    Right r -> log r


--polish tbl = either identity $ fold $ zipWith append basis (map (map (\x -> "e: 0" <> x <> "\n")) $ genMult gpTable 0 (Right emptyAS))

-- > log $ either identity (foldMap (\x -> "0" <> x <> "\n")) $ genMult gpTable 0 (Right emptyAS)

-- fcn r = foldl concat $ zipWith concat basis $ map ("0" <> _ <> "\n") r

-- A * B = a0 * B + a1 e1 * B + a2 e2 * B + a3 e3 * B + a4 e4 * B + a5 e23 * B + a6 e31 * B + a7 e12 * B + a8 e43 * B + a9 e42 * B
--       + a10 e41 * B + a11 e321 * B + a12 e124 * B + a13 e314 * B + a14 e234 * B + a15 e1234 * B
-- a0 * B = a0 * b0 + a0 * b1 e1 +

-- elemIndex :: forall a . Eq a => a -> Array a -> Maybe Int
-- !! -- index :: forall a. Array a -> Int -> Maybe a


-- lookupBasis tbl a b = tbl !! a !! b
-- lookupBasis :: Array (Array String) -> Int -> Int -> Maybe String
-- lookupBasis :: BasisTable -> Int -> Int -> Maybe String
-- lookupBasis tbl a b =
--   case tbl !! a of
--   Nothing -> Nothing
--   Just x -> x !! b

-- lb :: BasisTable -> Int -> Int -> Maybe String
-- lb tbl a b = do
--   x <- tbl !! a
--   x !! b
{-
newBasis :: BasisTable -> Int -> Int -> Maybe String
newBasis tbl a b = do -- elemIndex basis (tbl !! a !! b)
  x <- tbl !! a
  y <- x !! b
  pure (elemIndex basis y)

genMult tbl = do
  a <- 0 .. 15
  b <- 0 .. 15
  pure (tbl !! a !! b) <> "a." <> basis !! a <> " * " <> "b." <> basis !! b


newBasis :: BasisTable -> Int -> Int -> Maybe String
newBasis tbl a b = do -- elemIndex basis (tbl !! a !! b)
  x <- tbl !! a
  y <- x !! b
  pure (elemIndex basis y)

-- index :: forall a. Array a -> Int -> Maybe a

type BasisTable = Array (Array String)
type Multiply = String
genMult :: BasisTable -> String -> Multiply
genMult tbl name mult = ""
 -}
